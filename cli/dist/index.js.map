{"version":3,"sources":["../src/index.ts","../src/commands/add.ts","../src/utils/getConfig.ts","../src/config/config.ts","../src/utils/writeFile.ts","../src/utils/toCamelCase.ts"],"sourcesContent":["#!/usr/bin/env node\r\nimport { Command } from \"commander\";\r\nimport { add } from \"./commands/add.js\";\r\nimport path from \"path\";\r\n\r\nasync function main() {\r\n  const program = new Command()\r\n    .name(\"layers-ui\")\r\n    .description(\"Adds pre-made components to projects\")\r\n    .version(\"1.0.0\");\r\n\r\n  program.addCommand(add);\r\n\r\n  program.parse(process.argv);\r\n}\r\n\r\nfunction test() {\r\n  // const cwd = path.resolve(\"./src/components\");\r\n  // console.log(cwd);\r\n}\r\n\r\nif (process.argv[2] === \"test\") {\r\n  test();\r\n} else {\r\n  main();\r\n}\r\n","import { Command } from \"commander\";\r\nimport { getConfig } from \"../utils/getConfig.js\";\r\nimport { prisma } from \"../config/config.js\";\r\nimport { z } from \"zod\";\r\nimport { writeFileTo } from \"../utils/writeFile.js\";\r\nimport path from \"path\";\r\nimport { toCamelCase } from \"../utils/toCamelCase.js\";\r\n\r\nconst addArgumentsSchema = z.object({\r\n  components: z.array(z.string()),\r\n});\r\n\r\nexport const add = new Command()\r\n  .name(\"add\")\r\n  .description(\"adds component to your project\")\r\n  .argument(\"[components...]\", \"components to add\")\r\n  .action(async (components) => {\r\n    try {\r\n      const config = await getConfig();\r\n\r\n      const options = addArgumentsSchema.parse({ components });\r\n\r\n      const availableComponentNames = (\r\n        await prisma.component.findMany({\r\n          select: {\r\n            name: true,\r\n          },\r\n        })\r\n      ).map((component) => component.name);\r\n\r\n      // Check for invalid component names\r\n      const validComponentNames: string[] = [];\r\n      const invalidComponentNames: string[] = [];\r\n\r\n      options.components.forEach((name) => {\r\n        if (availableComponentNames.includes(name)) {\r\n          validComponentNames.push(name);\r\n        } else {\r\n          invalidComponentNames.push(name);\r\n        }\r\n      });\r\n\r\n      // Display invalid component names if they exist\r\n      if (invalidComponentNames.length > 0) {\r\n        console.log(\"Ignoring Invalid Component Names: \");\r\n        invalidComponentNames.forEach((names, i) => {\r\n          console.log(` [${i + 1}] ${names}`);\r\n        });\r\n      }\r\n\r\n      // Fetch valid components\r\n      const componentsData = await prisma.component.findMany({\r\n        select: {\r\n          content: true,\r\n          name: true,\r\n        },\r\n        where: {\r\n          name: {\r\n            in: validComponentNames,\r\n          },\r\n        },\r\n      });\r\n\r\n      componentsData.forEach(async (component) => {\r\n        const fileName = toCamelCase(component.name, \"-\") + \".tsx\";\r\n        await writeFileTo({\r\n          path: path.resolve(process.cwd(), config.path.components),\r\n          name: fileName,\r\n          file: component.content,\r\n        });\r\n      });\r\n      console.log(componentsData);\r\n    } catch (err) {\r\n      console.log(err);\r\n    }\r\n  });\r\n","import { z } from \"zod\";\r\nimport fs from \"fs/promises\";\r\n\r\nconst configSchema = z.object({\r\n  path: z.object(\r\n    {\r\n      utils: z.string({ message: \"utils path is missing\" }),\r\n      components: z.string({ message: \"components path is missing\" }),\r\n    },\r\n    { message: \"`path` config is missing \" }\r\n  ),\r\n});\r\n\r\nexport type ConfigSchema = z.infer<typeof configSchema>;\r\n\r\n/**\r\n * Retrieves components.json file config from root directory\r\n */\r\nexport async function getConfig() {\r\n  const cwd = process.cwd();\r\n  const rawConfig = await fs.readFile(`${cwd}/components.json`, \"utf-8\");\r\n  const config = JSON.parse(rawConfig);\r\n\r\n  const validatedConfig = configSchema.safeParse(config);\r\n  if (!validatedConfig.success) {\r\n    throw new Error(\"Invalid configuration file\");\r\n  }\r\n\r\n  return validatedConfig.data;\r\n}\r\n","import { PrismaClient } from \"@prisma/client\";\r\n\r\nexport const prisma = new PrismaClient();\r\n","import fs from \"fs/promises\";\r\n\r\nexport async function fileExists(path: string) {\r\n  try {\r\n    await fs.access(path);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function writeFileTo({\r\n  path,\r\n  file,\r\n  name,\r\n}: {\r\n  path: string;\r\n  file: string;\r\n  name: string;\r\n}) {\r\n  const fileAlreadyExists = await fileExists(path);\r\n  if (fileAlreadyExists) {\r\n    throw new Error(`File with the name ${name} already exists`);\r\n  }\r\n\r\n  await fs.writeFile(`${path}/${name}`, file);\r\n  return \"Successfuly written file\";\r\n}\r\n","export function toCamelCase(input: string, delimiter: string) {\r\n  const capitalizedWords = input\r\n    .split(delimiter)\r\n    .map((word) => `${word.split(\"\")[0].toUpperCase()}${word.slice(1)}`);\r\n  return capitalizedWords.join(\"\");\r\n}\r\n"],"mappings":"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","names":["Command","Command","z","fs","configSchema","getConfig","cwd","rawConfig","config","validatedConfig","PrismaClient","prisma","z","fs","fileExists","path","writeFileTo","file","name","path","toCamelCase","input","delimiter","word","addArgumentsSchema","z","add","Command","components","config","getConfig","options","availableComponentNames","prisma","component","validComponentNames","invalidComponentNames","name","names","i","componentsData","fileName","toCamelCase","writeFileTo","path","err","main","program","Command","add","main"]}
{"version":3,"sources":["../src/index.ts","../src/commands/add.ts","../src/utils/getConfig.ts","../src/config/config.ts","../src/utils/toPascalCase.ts","../src/utils/installComponent.ts","../src/utils/writeFile.ts","../src/utils/resolveComponentImports.ts","../src/utils/getComponentsFromDB.ts","../src/utils/logger.ts","../src/utils/checkInstalledPackages.ts","../src/utils/installPackage.ts"],"sourcesContent":["#!/usr/bin/env node\r\nimport { Command } from \"commander\";\r\nimport { add } from \"./commands/add.js\";\r\n\r\nasync function main() {\r\n  try {\r\n    const program = new Command()\r\n      .name(\"layers-ui\")\r\n      .description(\"Adds pre-made components to projects\")\r\n      .version(\"1.0.0\");\r\n\r\n    program.addCommand(add);\r\n\r\n    program.parse(process.argv);\r\n  } catch (err) {\r\n    console.log((err as Error).message);\r\n  }\r\n}\r\n\r\nfunction test() {\r\n  // const cwd = path.resolve(\"./src/components\");\r\n  // console.log(cwd);\r\n}\r\n\r\nif (process.argv[2] === \"test\") {\r\n  test();\r\n} else {\r\n  main();\r\n}\r\n","import { Command } from \"commander\";\r\nimport { getConfig } from \"../utils/getConfig.js\";\r\nimport { prisma } from \"../config/config.js\";\r\nimport { z } from \"zod\";\r\nimport prompts from \"prompts\";\r\nimport { installComponent } from \"../utils/installComponent.js\";\r\nimport { getComponentsFromDB } from \"../utils/getComponentsFromDB.js\";\r\nimport { logger } from \"../utils/logger.js\";\r\nimport chalk from \"chalk\";\r\nimport ora from \"ora\";\r\nimport { checkInstalledPackages } from \"../utils/checkInstalledPackages.js\";\r\nimport { installPackage } from \"../utils/installPackage.js\";\r\n\r\nconst addArgumentsSchema = z.object({\r\n  components: z.array(z.string()),\r\n});\r\n\r\nexport const add = new Command()\r\n  .name(\"add\")\r\n  .description(\"adds component to your project\")\r\n  .argument(\"[components...]\", \"components to add\")\r\n  .action(async (components) => {\r\n    try {\r\n      const config = await getConfig();\r\n\r\n      const options = addArgumentsSchema.parse({ components });\r\n\r\n      const availableComponentNames = (\r\n        await prisma.component.findMany({\r\n          select: {\r\n            name: true,\r\n          },\r\n        })\r\n      ).map((component) => component.name);\r\n\r\n      // Check for invalid component names\r\n      const validComponentNames: string[] = [];\r\n      const invalidComponentNames: string[] = [];\r\n\r\n      options.components.forEach((name) => {\r\n        if (availableComponentNames.includes(name)) {\r\n          validComponentNames.push(name);\r\n        } else {\r\n          invalidComponentNames.push(name);\r\n        }\r\n      });\r\n\r\n      // Display invalid component names if they exist\r\n      if (invalidComponentNames.length > 0) {\r\n        console.log(\r\n          chalk.yellow(\"Ignoring Invalid Component Names:\"),\r\n          invalidComponentNames.join(\", \")\r\n        );\r\n      }\r\n\r\n      // If user doesnt pass in a component as argument, display a prompt style menu\r\n      let selectedComponentNames = validComponentNames;\r\n      if (options.components.length <= 0) {\r\n        const { components } = await prompts({\r\n          instructions: false,\r\n          type: \"multiselect\",\r\n          hint: \"Press [space] to select, [a] to select all, [enter] to submit\",\r\n          name: \"components\",\r\n          message: \"Select components\",\r\n          choices: availableComponentNames.map((component) => {\r\n            return { title: component, value: component };\r\n          }),\r\n        });\r\n        selectedComponentNames = components;\r\n      }\r\n\r\n      if (selectedComponentNames.length <= 0) {\r\n        logger.info(\"No valid components selected, exiting.\");\r\n        return;\r\n      }\r\n\r\n      // Get the list of installed packages.\r\n      const installedPackages = await checkInstalledPackages();\r\n\r\n      // Install components and their dependencies using BFS travesal\r\n      const componentsData = await getComponentsFromDB(selectedComponentNames);\r\n      const installed = new Set<string>();\r\n      let queue = componentsData;\r\n\r\n      const packagesToBeInstalled: string[] = [];\r\n      while (queue.length > 0) {\r\n        // Install components on the current level\r\n        const spinner = ora(\"Installing components...\").start();\r\n        await Promise.all(\r\n          queue.map((component) => {\r\n            // Mark the installed components as `installed` (aka visited)\r\n            installed.add(component.name);\r\n            return installComponent(component, config);\r\n          })\r\n        );\r\n        spinner.stop();\r\n\r\n        // Traverse to neighbouring components\r\n        const toBeInstalled: string[] = [];\r\n        for (const { dependencies } of queue) {\r\n          for (const dependencyName of dependencies) {\r\n            // Append package names that needs to be installed (not included inside the package.json file)\r\n            if (dependencyName.includes(\"package/\")) {\r\n              const packageName = dependencyName.replace(\"package/\", \"\");\r\n              if (\r\n                !installedPackages.includes(packageName.replace(\"dev/\", \"\")) &&\r\n                !packagesToBeInstalled.includes(packageName)\r\n              ) {\r\n                packagesToBeInstalled.push(packageName);\r\n              }\r\n              continue;\r\n            }\r\n\r\n            // Mark the dependency as visited\r\n            const name = dependencyName.replace(\"component/\", \"\");\r\n            if (!installed.has(name)) {\r\n              toBeInstalled.push(name);\r\n              installed.add(name);\r\n            }\r\n          }\r\n        }\r\n        queue = [];\r\n\r\n        if (toBeInstalled.length > 0) {\r\n          const spinner = ora(\"Fetching components...\").start();\r\n          queue = await getComponentsFromDB(toBeInstalled);\r\n          spinner.stop();\r\n        }\r\n      }\r\n\r\n      // Install the necessary packages\r\n      if (packagesToBeInstalled.length > 0) {\r\n        const spinner = ora(\"Installing dependencies...\").start();\r\n        await installPackage(packagesToBeInstalled);\r\n        spinner.succeed(\"Completed dependency installation\");\r\n      }\r\n    } catch (err) {\r\n      console.log(err);\r\n    }\r\n  });\r\n","import { z } from \"zod\";\r\nimport fs from \"fs/promises\";\r\n\r\nconst configSchema = z.object({\r\n  path: z.object(\r\n    {\r\n      utils: z.string({ message: \"utils path is missing\" }),\r\n      components: z.string({ message: \"components path is missing\" }),\r\n    },\r\n    { message: \"`path` config is missing \" }\r\n  ),\r\n});\r\n\r\nexport type ConfigSchema = z.infer<typeof configSchema>;\r\n\r\n/**\r\n * Retrieves components.json file config from root directory\r\n */\r\nexport async function getConfig() {\r\n  const cwd = process.cwd();\r\n  const rawConfig = await fs.readFile(`${cwd}/components.json`, \"utf-8\");\r\n  const config = JSON.parse(rawConfig);\r\n\r\n  const validatedConfig = configSchema.safeParse(config);\r\n  if (!validatedConfig.success) {\r\n    throw new Error(\"Invalid configuration file\");\r\n  }\r\n\r\n  return validatedConfig.data;\r\n}\r\n","import { PrismaClient } from \"@prisma/client\";\r\n\r\nexport const prisma = new PrismaClient();\r\n","export function toPascalCase(input: string, delimiter: string, join?: string) {\r\n  const capitalizedWords = input\r\n    .split(delimiter)\r\n    .map((word) => `${word.split(\"\")[0].toUpperCase()}${word.slice(1)}`);\r\n  return capitalizedWords.join(join || \"\");\r\n}\r\n","import { toPascalCase } from \"./toPascalCase.js\";\r\nimport ora from \"ora\";\r\nimport path from \"path\";\r\nimport { Component } from \"@prisma/client\";\r\nimport { writeFileTo } from \"./writeFile.js\";\r\nimport { resolveComponentImports } from \"./resolveComponentImports.js\";\r\nimport { ConfigSchema } from \"./getConfig.js\";\r\n\r\nexport async function installComponent(\r\n  component: Omit<Component, \"id\">,\r\n  config: ConfigSchema,\r\n  opts?: { replace?: boolean }\r\n) {\r\n  const spinner = ora(`Writing ${component.name}...`).start();\r\n  const fileName = toPascalCase(component.name, \"-\") + \".tsx\";\r\n  const successfulyWrittenFile = await writeFileTo({\r\n    path: path.resolve(process.cwd(), \".\" + config.path.components),\r\n    name: fileName,\r\n    file: resolveComponentImports(component.content, config.path),\r\n    replace: opts?.replace,\r\n  });\r\n  if (successfulyWrittenFile) {\r\n    spinner.succeed(\r\n      `Successfuly inserted ${toPascalCase(component.name, \"-\", \" \")}.`\r\n    );\r\n  } else {\r\n    spinner.stop();\r\n  }\r\n\r\n  // if (packageDependencies.length > 0) {\r\n  //   try {\r\n  //     await execa(\"npm\", [\"install\", \"-D\", ...packageDependencies], {\r\n  //       cwd: process.cwd(),\r\n  //     });\r\n  //   } catch (err) {\r\n  //     console.log(err);\r\n  //     spinner.fail(\"Failed to install dependencies\");\r\n  //   }\r\n  // }\r\n}\r\n","import fs from \"fs/promises\";\r\n\r\nexport async function fileExists(path: string) {\r\n  try {\r\n    await fs.stat(path);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function writeFileTo({\r\n  path,\r\n  file,\r\n  name,\r\n  replace,\r\n}: {\r\n  path: string;\r\n  file: string;\r\n  name: string;\r\n  replace?: boolean;\r\n}) {\r\n  const pathWithFileName = `${path}/${name}`;\r\n  const fileAlreadyExists = await fileExists(pathWithFileName);\r\n  if (fileAlreadyExists && !replace) {\r\n    return false;\r\n  }\r\n\r\n  await fs.writeFile(pathWithFileName, file);\r\n  return true;\r\n}\r\n","import { ConfigSchema } from \"./getConfig.js\";\r\n\r\nexport function resolveComponentImports(\r\n  file: string,\r\n  paths: ConfigSchema[\"path\"]\r\n) {\r\n  return file\r\n    .replace(\"@/components/ui\", `${paths.components.replace(\"/src\", \"@\")}`)\r\n    .replace(\"@/utils/lib\", `${paths.utils.replace(\"/src\", \"@\")}`);\r\n}\r\n","import { prisma } from \"../config/config.js\";\r\n\r\nexport function getComponentsFromDB(componentNames: string[]) {\r\n  return prisma.component.findMany({\r\n    select: {\r\n      content: true,\r\n      name: true,\r\n      dependencies: true,\r\n    },\r\n    where: {\r\n      name: {\r\n        in: componentNames,\r\n      },\r\n    },\r\n  });\r\n}\r\n","import chalk from \"chalk\";\r\n\r\nexport const logger = {\r\n  error(...args: unknown[]) {\r\n    console.log(chalk.red(...args));\r\n  },\r\n  warn(...args: unknown[]) {\r\n    console.log(chalk.yellow(...args));\r\n  },\r\n  info(...args: unknown[]) {\r\n    console.log(chalk.cyan(...args));\r\n  },\r\n  success(...args: unknown[]) {\r\n    console.log(chalk.green(...args));\r\n  },\r\n  break() {\r\n    console.log(\"\");\r\n  },\r\n};\r\n","import fs from \"fs/promises\";\r\nimport path from \"path\";\r\n\r\nexport async function checkInstalledPackages() {\r\n  const packageJsonPath = path.resolve(process.cwd(), \"package.json\");\r\n  const packageJson = JSON.parse(await fs.readFile(packageJsonPath, \"utf-8\"));\r\n\r\n  const installedPackages = [\r\n    ...Object.keys(packageJson.dependencies || {}),\r\n    ...Object.keys(packageJson.devDependencies || {}),\r\n  ];\r\n\r\n  return installedPackages;\r\n}\r\n","import { execa } from \"execa\";\r\n\r\nexport async function installPackage(packages: string[]) {\r\n  try {\r\n    const devDepedencies: string[] = [];\r\n    const dependencies: string[] = [];\r\n\r\n    packages.forEach((dep) => {\r\n      if (dep.includes(\"dev/\")) {\r\n        devDepedencies.push(dep.replace(\"dev/\", \"\"));\r\n      } else {\r\n        dependencies.push(dep);\r\n      }\r\n    });\r\n\r\n    await execa(\"npm\", [\"install\", \"-D\", ...devDepedencies], {\r\n      cwd: process.cwd(),\r\n    });\r\n\r\n    await execa(\"npm\", [\"install\", ...dependencies], {\r\n      cwd: process.cwd(),\r\n    });\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n"],"mappings":"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","names":["Command","Command","z","fs","configSchema","getConfig","cwd","rawConfig","config","validatedConfig","PrismaClient","prisma","z","prompts","toPascalCase","input","delimiter","join","word","ora","path","fs","fileExists","path","writeFileTo","file","name","replace","pathWithFileName","resolveComponentImports","file","paths","installComponent","component","config","opts","spinner","ora","fileName","toPascalCase","writeFileTo","path","resolveComponentImports","getComponentsFromDB","componentNames","prisma","chalk","logger","args","chalk","ora","fs","path","checkInstalledPackages","packageJsonPath","packageJson","execa","installPackage","packages","devDepedencies","dependencies","dep","addArgumentsSchema","z","add","Command","components","config","getConfig","options","availableComponentNames","prisma","component","validComponentNames","invalidComponentNames","name","chalk","selectedComponentNames","prompts","logger","installedPackages","checkInstalledPackages","componentsData","getComponentsFromDB","installed","queue","packagesToBeInstalled","spinner","ora","installComponent","toBeInstalled","dependencies","dependencyName","packageName","installPackage","err","main","program","Command","add","err","main"]}